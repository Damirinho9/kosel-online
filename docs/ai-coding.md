# AI Coding Rules - Козёл Помощник

## Общие принципы

### 1. Spec перед кодом

Любая задача начинается с краткого spec:
- **Что** делаем (баг/фича/рефакторинг)
- **Где** проблема (какие файлы)
- **Зачем** это нужно (контекст, цель)
- **Ограничения** (что не ломать)
- **Definition of Done** (как проверить готовность)

Если spec неполный — сначала уточни у пользователя, потом лезь в код.

### 2. Работать точечно

- Одна задача = один модуль/функция
- Не переписывать всё с нуля без явного запроса
- Минимальные изменения для решения задачи
- Не трогать код, который работает и не связан с задачей

### 3. Feedback-loop обязателен

После любых изменений:
```bash
bash scripts/check_all.sh
```

Если проверка падает:
- Проси логи у пользователя
- Анализируй конкретную ошибку
- Предлагай минимальный фикс
- Не глуши ошибки ради зелёных тестов

## Chrome Extension специфика

### Манифест (manifest.json)

**Что нельзя:**
- Менять `manifest_version` (всегда 3)
- Удалять permissions без понимания последствий
- Менять `matches` в content_scripts без тестирования на реальной странице

**Правила:**
- При добавлении новых Chrome APIs → добавлять permission
- При изменении структуры файлов → обновлять paths в манифесте
- Всегда проверять манифест через `scripts/check_all.sh` после изменений

### Background Service Worker (background.js)

**Критичные особенности:**
- Service Worker может быть остановлен браузером в любой момент
- Нет доступа к DOM
- CSP запрещает `eval()`, `new Function()`, `importScripts()` для не-статических скриптов
- Все асинхронные операции → Promise

**Что нельзя:**
- Использовать синхронные API
- Полагаться на глобальное состояние (может быть сброшено)
- Загружать TensorFlow.js напрямую (только через offscreen document)

**Правила:**
- Всегда `return true` в chrome.runtime.onMessage.addListener для async
- Обрабатывать ошибки создания offscreen document
- Логировать все критичные события

### Content Scripts (content.js)

**Критичные особенности:**
- Работает в isolated world (не видит window.* переменные страницы)
- Может читать/изменять DOM
- CSP страницы может блокировать загрузку ресурсов
- Инжектится на каждой странице kozel-online.com/*

**Что нельзя:**
- Загружать внешние скрипты (tf.min.js) напрямую
- Полагаться на стабильность DOM селекторов (сайт может измениться)
- Блокировать main thread длительными операциями

**Правила:**
- Все ML операции через chrome.runtime.sendMessage → background → offscreen
- Проверять существование DOM элементов перед парсингом
- Использовать try-catch для парсинга состояния игры
- Дебаунсить частые операции (MutationObserver)

### Offscreen Document (offscreen.js)

**Критичные особенности:**
- Единственное место, где работает TensorFlow.js
- Может быть уничтожен браузером
- Не имеет доступа к DOM
- Изолирован от content scripts

**Что нельзя:**
- Менять архитектуру ML модели без версионирования (сломает загрузку из IndexedDB)
- Полагаться на постоянное существование (background.js пересоздает при необходимости)
- Использовать синхронные операции TensorFlow.js

**Правила:**
- Всегда await для tf.* операций
- Обрабатывать ошибки загрузки/сохранения модели
- Логировать все ML операции (predict, train, save, load)
- Возвращать structured responses { success, prediction/stats, error }

## ML компоненты

### ml-encoder.js

**Что нельзя:**
- Менять размерность векторов (159 для state, 36 для action) без синхронного изменения ml-model.js
- Менять порядок кодирования признаков (сломает обученную модель)

**Правила:**
- Версионировать формат кодирования (добавить поле `encoderVersion`)
- Документировать структуру вектора в комментариях
- Валидировать входные данные (проверять на null/undefined)

### ml-model.js

**Что нельзя:**
- Менять архитектуру сети без миграции (пользователи потеряют обученные модели)
- Менять версию TensorFlow.js без проверки совместимости
- Удалять методы save/load

**Правила:**
- Всегда dispose() тензоров после использования (утечки памяти)
- Использовать tf.tidy() для автоматической очистки
- Логировать метрики обучения (loss, accuracy)
- Хранить stats (gamesPlayed, lastTrainedDate, modelVersion)

### move-history.js

**Что нельзя:**
- Менять схему данных в IndexedDB без миграции
- Хранить слишком много игр (ограничение: последние 100 игр)

**Правила:**
- Использовать IndexedDB transactions
- Обрабатывать ошибки quota exceeded
- Периодически чистить старые игры

## Стратегии (ai/strategy.js)

**Что нельзя:**
- Менять публичный API метода `chooseCard(gameState, mlPrediction)`
- Удалять fallback эвристики (ML может быть недоступен)
- Изменять threshold уверенности ML (0.6/0.8) без A/B тестирования

**Правила:**
- ML предсказание — это подсказка, не императив
- При confidence < 0.6 использовать эвристики
- При confidence 0.6-0.8 комбинировать ML + эвристики
- При confidence > 0.8 доверять ML
- Логировать reasoning для каждого решения

## Работа с DOM (парсинг игры)

**Критичные селекторы:**
```javascript
// Примеры (актуальные селекторы в content.js):
'.my-cards .card'        // Карты игрока
'.table .card'           // Карты на столе
'.trump-indicator'       // Козырь
'.game-over'             // Окончание игры
```

**Что нельзя:**
- Использовать хрупкие селекторы (nth-child, точные классы)
- Полагаться на порядок элементов
- Игнорировать null/undefined при парсинге

**Правила:**
- Проверять существование элементов перед доступом
- Использовать data-атрибуты если доступны
- Fallback на множественные селекторы
- Логировать ошибки парсинга (не краши, если структура изменилась)

## Не ломать публичные API

### Контракты между модулями:

**content.js ↔ background.js:**
```javascript
// Запросы:
{ action: 'mlPredict', data: { gameState, legalCards } }
{ action: 'mlTrain', data: { trainingData } }
{ action: 'mlStatus' }

// Ответы:
{ success: true, prediction: { card, confidence } }
{ success: true, stats: { ... } }
{ initialized: boolean, available: boolean, stats, error }
```

**strategy.js API:**
```javascript
static async chooseCard(gameState, mlPrediction = null) → {
  cardIndex: number,
  card: Card,
  reasoning: string
}
```

**Изменение контрактов требует:**
- Обновление всех мест использования
- Backward compatibility или миграция данных
- ADR с обоснованием

## Не глушить ошибки

**Плохо:**
```javascript
try {
  await mlModel.train(data);
} catch (e) {
  // Молча игнорируем
}
```

**Хорошо:**
```javascript
try {
  await mlModel.train(data);
  console.log('[ML] ✓ Обучение завершено');
  return { success: true };
} catch (error) {
  console.error('[ML] ✗ Ошибка обучения:', error.message);
  return { success: false, error: error.message };
}
```

## Не делать "большую переделку"

**Без явного запроса пользователя НЕ:**
- Переписывать всю систему стратегий
- Менять архитектуру ML модели
- Рефакторить весь content.js
- Переходить на TypeScript
- Внедрять новые библиотеки

**Допустимо без запроса:**
- Фикс конкретного бага
- Добавление логирования
- Улучшение обработки ошибок в конкретном месте
- Оптимизация одной функции

## Не менять форматы данных

**Хранимые данные:**

1. **IndexedDB "KozelGames"** (история игр для ML)
2. **IndexedDB "tensorflowjs"** (модель ML)
3. **chrome.storage.local** (настройки, статистика)

**Правила:**
- Версионировать схему данных
- Миграция при изменении формата
- Не удалять поля без миграции (backward compatibility)

## Критичные зоны — не трогать без обсуждения

### 1. Offscreen Document Lifecycle

**Файлы:**
- `background.js` (setupOffscreenDocument, forwardToOffscreen)

**Почему:** Неправильная логика создания → ML перестанет работать.

### 2. ML Model Serialization

**Файлы:**
- `ai/ml-model.js` (save, load, getModelPath)

**Почему:** Поломка загрузки → пользователи потеряют обученные модели.

### 3. Game State Encoding

**Файлы:**
- `ai/ml-encoder.js` (encodeGameState, encodeAction)

**Почему:** Изменение формата → обученная модель станет бесполезной.

### 4. Chrome Extension Permissions

**Файлы:**
- `manifest.json` (permissions, host_permissions)

**Почему:** Удаление permission → функциональность сломается. Добавление permission → пользователи должны переодобрить расширение.

## Тестирование изменений

### Manual Testing Checklist:

После изменений:

1. **Перезагрузить расширение:**
   ```
   chrome://extensions/ → кнопка обновления
   ```

2. **Открыть kozel-online.com**

3. **Проверить консоль (F12):**
   - Нет ошибок при загрузке
   - ML инициализирован (или логи о причине недоступности)
   - Рекомендации отображаются

4. **Сыграть тестовую игру:**
   - Рекомендации корректны
   - ML обучается после игры (если доступен)
   - Нет крашей

5. **Проверить UI панель:**
   - Панель видна и не мешает игре
   - Reasoning понятен
   - Стили корректны

### Автоматическая проверка:

```bash
bash scripts/check_all.sh
```

Включает:
- Валидацию manifest.json
- Проверку обязательных файлов
- Проверку синтаксиса JavaScript (базовая)

## Workflow для задач

### Баг-фикс:

1. Получить spec: что сломано, где, как воспроизвести
2. Прочитать docs/architecture.md для контекста модуля
3. Найти root cause (не симптом!)
4. Предложить минимальный фикс
5. Объяснить, что именно чинится и почему
6. После применения → `bash scripts/check_all.sh`
7. Попросить пользователя протестировать
8. Если работает → коммит

### Новая фича:

1. Получить полный spec (см. раздел "Общие принципы")
2. Прочитать docs/architecture.md и релевантные ADR
3. Проверить: нужен ли новый ADR? (если меняем архитектуру)
4. Предложить план: какие файлы затронуты, что проверяем
5. Согласовать с пользователем
6. Имплементировать точечно (не переписывать всё)
7. После применения → `bash scripts/check_all.sh`
8. Попросить тестирование
9. Обновить docs/ если нужно
10. Коммит

### Рефакторинг:

1. Убедиться, что пользователь запросил рефакторинг явно
2. Определить scope (один модуль, не всё)
3. Не менять публичные API
4. Не менять поведение (только структуру кода)
5. После применения → `bash scripts/check_all.sh`
6. Убедиться, что функциональность не сломалась

## Коммит-сообщения

Формат:
```
<Краткое описание изменения>

<Детали: что и почему изменено>

<Список изменений:>
- Файл 1: что сделано
- Файл 2: что сделано

<Технические детали если нужно>
```

Пример:
```
Исправлена ошибка парсинга козырной масти

При изменении структуры DOM kozel-online.com селектор '.trump-indicator'
перестал работать. Добавлен fallback на data-атрибут.

Изменения:
- content.js: добавлен fallback селектор для козыря
- content.js: добавлена валидация существования элемента

Теперь расширение корректно определяет козырь даже если структура DOM изменена.
```

## Чеклист перед каждым изменением

- [ ] Прочитал spec задачи
- [ ] Прочитал docs/architecture.md для контекста
- [ ] Проверил релевантные ADR
- [ ] Понял, какие файлы затронуты
- [ ] Понял, что НЕ должно сломаться
- [ ] Предложил план пользователю
- [ ] Получил подтверждение (если задача нетривиальна)

## Чеклист после каждого изменения

- [ ] Запустил `bash scripts/check_all.sh`
- [ ] Проверил, что не сломал публичные API
- [ ] Проверил, что не заглушил ошибки
- [ ] Добавил логирование если нужно
- [ ] Обновил docs/ если изменилась архитектура
- [ ] Предложил пользователю тестирование
- [ ] Написал понятное коммит-сообщение
